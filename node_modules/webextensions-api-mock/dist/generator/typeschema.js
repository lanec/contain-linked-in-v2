"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("./helper");
class TypeSchemaGenerator {
    constructor(interfaceName, namespace, out) {
        this.name = '';
        this.interfaceName = interfaceName;
        this.out = out;
        this.typeSchemasArray(namespace.functions);
        this.typeSchemasArray(namespace.events, 'event');
        this.typeSchemasArray(namespace.types);
        this.typeSchemasObject(namespace.properties);
    }
    typeSchemasArray(typeSchemas, type) {
        if (!typeSchemas)
            return;
        typeSchemas.forEach(typeSchema => {
            if (type)
                typeSchema.type = type;
            this.typeSchema(typeSchema);
        });
    }
    typeSchemasObject(typeSchemas) {
        if (!typeSchemas)
            return;
        Object.keys(typeSchemas).forEach(typeSchemaName => {
            if (!typeSchemas)
                return;
            const typeSchema = typeSchemas[typeSchemaName];
            typeSchema.name = typeSchemaName;
            this.typeSchema(typeSchema);
        });
    }
    typeSchema(typeSchema) {
        const name = typeSchema.id || typeSchema.name;
        if (!name)
            return;
        this.name = name;
        if (typeSchema.$ref) {
            const refParts = typeSchema.$ref.split('.');
            if (refParts.length === 1) {
                this.out.parent.push(`${this.name}: ${this.interfaceName}["${typeSchema.$ref}"];`);
            }
            else {
                const last = refParts.pop();
                this.out.parent.push(`${this.name}: ${refParts
                    .map(refPart => helper_1.capitalize(refPart))
                    .join('')}["${last}"];`);
            }
        }
        if (typeSchema.type === 'string') {
            this.out.parent.push(`${this.name}: ${this.string(this.name, typeSchema.enum)};`);
        }
        if (typeSchema.type === 'function') {
            const fnOut = this.fn(typeSchema);
            if (fnOut)
                this.out.parent.push(fnOut);
        }
        if (typeSchema.type === 'event') {
            const eventOut = this.event(typeSchema);
            if (eventOut)
                this.out.parent.push(eventOut);
        }
        if (typeSchema.type === 'object') {
            this.object(typeSchema);
        }
        if (typeSchema.value) {
            this.out.parent.push(`${typeSchema.name}: ${typeSchema.value};`);
        }
    }
    object(obj) {
        const out = ['{'];
        if (obj.functions) {
            obj.functions.forEach(fn => {
                const fnOut = this.fn(fn);
                if (fnOut)
                    out.push(fnOut);
            });
        }
        if (obj.events) {
            obj.events.forEach(event => {
                const eventOut = this.event(event);
                if (eventOut)
                    out.push(eventOut);
            });
        }
        if (obj.properties) {
            Object.keys(obj.properties).forEach(propertyName => {
                if (!obj.properties)
                    return;
                const property = obj.properties[propertyName];
                if (!property.type)
                    return;
                this.objectProperty(out, propertyName, property);
            });
        }
        out.push('}');
        this.out.parent.push(`${this.name}: ${out.join('\n')};`);
    }
    fn(fn) {
        if (!fn.name)
            return false;
        return `${fn.name}${fn.unsupported ? '?' : ''}: sinon.SinonStub;`;
    }
    event(event) {
        if (!event.name)
            return false;
        return `${event.name}${event.unsupported ? '?' : ''}: SinonEventStub;`;
    }
    string(name, enums) {
        return enums ? this.enum(name, enums) : 'string[]';
    }
    objectProperty(out, propertyName, property) {
        var _a;
        if (property.type &&
            ['string', 'boolean', 'integer', 'any'].includes(property.type)) {
            const type = property.type === 'integer' ? 'number' : property.type;
            out.push(`${this.key(propertyName, property.optional)} ${type};`);
        }
        if (property.type === 'array' && ((_a = property.items) === null || _a === void 0 ? void 0 : _a.type) === 'string') {
            out.push(`${this.key(propertyName, property.optional)} ${this.string(propertyName, property.items.enum)};`);
        }
    }
    key(name, optional) {
        return `${name}${optional ? '?' : ''}:`;
    }
    enum(name, enums) {
        const childName = `${this.interfaceName}${helper_1.capitalize(name)}`;
        this.out.childTypes.push(`type ${childName} = '${enums
            .map(entry => {
            if (typeof entry === 'object') {
                return entry.name;
            }
            else {
                return entry;
            }
        })
            .join("' | '")}';`);
        return `${childName}[]`;
    }
}
exports.TypeSchemaGenerator = TypeSchemaGenerator;
